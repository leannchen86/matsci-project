"""Research question generation for GNoME materials using Claude Code subagents.

The 1,700 questions in data/opus_questions.json were generated by launching 68
parallel Claude Code subagents (Task tool), each processing a batch of 25
materials. This approach uses Claude's reasoning directly — no Anthropic API
key or SDK required.

How it was done:
    1. Export compact material profiles from SQLite (validation scores, oxi
       states, crystal system, MP status) plus sibling materials sharing the
       same chemical system (chemsys family context).
    2. Split 1,700 materials into 68 batch JSON files.
    3. Launch 68 parallel subagents via Claude Code's Task tool. Each subagent
       reads its batch file, reasons about the chemistry, and writes one
       research question per material.
    4. Merge the 68 output files into data/opus_questions.json.
    5. Run `python -m gnome_auditor.export_data` to bake questions into data.js.

To regenerate or extend questions, use Claude Code with the Task tool to process
materials in parallel batches. The prompt guidance and data-prep helpers below
document the approach.

Usage (data export only — questions already generated):
    cd materials_discovery
    python -m gnome_auditor.export_data
"""

import json
from pathlib import Path

from gnome_auditor.config import DB_PATH, DATA_DIR
from gnome_auditor.export_data import (
    get_conn, export_materials, find_interesting_failures, compute_aggregate_stats,
)

OUTPUT_PATH = DATA_DIR / "opus_questions.json"

# -- Prompt guidance given to each subagent ----------------------------------

SYSTEM_PROMPT = """\
You are a materials scientist and ML researcher auditing GNoME crystal predictions \
using classical chemistry rules independent of the DFT/ML pipeline.

Generate exactly ONE research question. Keep it concise (a few sentences, not a \
giant paragraph). Self-contained with key numbers. Expert chemical insight, not statistics.

## What makes a GREAT question:
- References related materials in the same chemical system to identify PATTERNS \
("3 of 13 U-Pa-O compounds show GII>2.8, all Pa-rich — is Pa5+ poorly parameterized?")
- Proposes a specific testable hypothesis with the alternative worked out
- Connects to known chemistry or structural archetypes
- Challenges whether the validation method itself is appropriate for this material

## BAD questions (DO NOT write):
- "How can Tier 1 pass while Tier 2 fails?" — obvious
- "This is at the Xth percentile" — statistics without chemistry
- "Should this be synthesized?" — outside scope
- Generic "could the oxi state be wrong?" without proposing the specific alternative

## For CLEAN materials (all checks pass, low BVS):
Hypothesize WHY — easy chemistry? known structural archetype? over-optimized \
relaxation? Or note an anomaly hidden in the clean profile (e.g., space group mismatch).

Return ONLY the question text — no JSON wrapping, no categories, no metadata."""


def build_material_prompt(mat, aggregate_stats, family=None):
    """Build per-material prompt with full validation profile and dataset context.

    family: list of sibling materials in the same chemical system (chemsys).
    """
    checks = mat.get("checks", {})
    formula = mat.get("reduced_formula", "?")
    mat_id = mat.get("material_id", "?")

    lines = [
        f"## Material: {formula} (ID: {mat_id})",
        f"- Compound class: {mat.get('compound_class', '?')}",
        f"- Crystal system: {mat.get('crystal_system', '?')}, Space group: {mat.get('space_group', '?')} (#{mat.get('space_group_number', '?')})",
        f"- Sites: {mat.get('n_sites', '?')}",
        f"- Formation energy: {mat.get('formation_energy_per_atom', '?')} eV/atom",
        f"- Band gap: {mat.get('bandgap', '?')} eV",
        f"- MP status: {mat.get('match_type', '?')}",
        f"- Oxi method: {mat.get('oxi_method', '?')}, Confidence: {mat.get('oxi_confidence', '?')}",
        f"- Mixed valence: {mat.get('has_mixed_valence', False)}",
        "",
        "## Validation Results",
    ]

    check_order = ["charge_neutrality", "shannon_radii", "pauling_rule2", "bond_valence_sum", "space_group"]
    for cn in check_order:
        c = checks.get(cn, {})
        status = c.get("status", "not_run")
        if status == "completed":
            score = c.get("score")
            details = c.get("details", {})
            tier = c.get("tier", "?")
            lines.append(f"- **{cn}** (Tier {tier}): score = {score}")
            if cn == "bond_valence_sum" and isinstance(details, dict):
                worst = details.get("worst_sites", [])
                if worst:
                    sites_str = "; ".join(
                        f"{ws.get('element', '?')} site {ws.get('site_index', '?')}: "
                        f"BVS={ws.get('bvs', '?')}, expected={ws.get('expected', '?')}, "
                        f"deviation={ws.get('relative_deviation', '?')}"
                        for ws in worst[:3]
                    )
                    lines.append(f"  Worst sites: {sites_str}")
            if cn == "charge_neutrality" and isinstance(details, dict):
                lines.append(f"  Total charge: {details.get('total_charge', '?')}")
            if cn == "pauling_rule2" and isinstance(details, dict):
                n_checked = details.get("n_oxygen_sites_checked", "?")
                n_violated = details.get("n_violated", "?")
                lines.append(f"  O sites checked: {n_checked}, violated: {n_violated}")
                warn = details.get("compound_class_warning")
                if warn:
                    lines.append(f"  Warning: {warn}")
            if cn == "shannon_radii" and isinstance(details, dict):
                n_bonds = details.get("n_bonds_checked", "?")
                lines.append(f"  Bonds checked: {n_bonds}")
            if cn == "space_group" and isinstance(details, dict):
                top_sgs = details.get("top_experimental_space_groups", [])
                if top_sgs:
                    sg_str = ", ".join(
                        f"#{sg.get('space_group_number', '?')} ({sg.get('fraction', 0)*100:.0f}%)"
                        for sg in top_sgs[:3]
                    )
                    lines.append(f"  Top experimental SGs: {sg_str}")
        else:
            reason = ""
            if isinstance(c.get("details"), dict):
                reason = c["details"].get("skip_reason", "")
            lines.append(f"- **{cn}**: {status}" + (f" ({reason})" if reason else ""))

    # Dataset context
    lines.append("")
    lines.append("## Dataset Context (3,262 ternary O-containing compounds)")
    cs = aggregate_stats.get("check_stats", {})
    for cn in ["bond_valence_sum", "charge_neutrality", "pauling_rule2", "shannon_radii"]:
        s = cs.get(cn, {})
        if s.get("mean") is not None:
            lines.append(
                f"- {cn}: mean={s['mean']}, median={s['median']}, "
                f"P25={s['p25']}, P75={s['p75']} (n={s['n_completed']})"
            )

    mt = aggregate_stats.get("match_types", {})
    lines.append(f"- Match types: novel={mt.get('novel', 0)}, "
                 f"comp_known={mt.get('computationally_known', 0)}, "
                 f"exp_known={mt.get('experimentally_known', 0)}")

    # Related materials in same chemical system
    if family and len(family) > 1:
        siblings = [m for m in family if m["material_id"] != mat_id]
        if siblings:
            lines.append("")
            lines.append(f"## Related Materials ({len(siblings)} other predictions in same chemical system)")
            for sib in siblings[:8]:
                sib_checks = sib.get("checks", {})
                bvs = sib_checks.get("bond_valence_sum", {})
                cn = sib_checks.get("charge_neutrality", {})
                gii = bvs.get("score", "N/A") if bvs.get("status") == "completed" else "N/A"
                charge = cn.get("score", "N/A") if cn.get("status") == "completed" else "N/A"
                lines.append(
                    f"- {sib.get('reduced_formula', '?'):18s} "
                    f"SG={sib.get('space_group', '?'):10s} "
                    f"GII={gii!s:8s} charge={charge!s:8s} "
                    f"match={sib.get('match_type', '?')}"
                )

    return "\n".join(lines)


def get_subset_materials(materials, subset, max_count=None):
    """Filter materials by subset strategy."""
    if subset == "interesting":
        interesting = find_interesting_failures(materials)
        target_ids = set()
        for cat in interesting.values():
            for item in cat.get("items", []):
                target_ids.add(item["material_id"])
        mats = [m for m in materials if m["material_id"] in target_ids]
    elif subset == "novel":
        mats = [m for m in materials
                if m.get("match_type") == "novel" and m.get("n_completed", 0) >= 3]
    elif subset == "half":
        mats = [m for m in materials if m.get("n_completed", 0) >= 3]
        def sort_key(m):
            n = m.get("n_completed", 0)
            bvs = m.get("checks", {}).get("bond_valence_sum", {})
            gii = abs(bvs.get("score", 0)) if bvs.get("status") == "completed" else 0
            return (-n, -gii)
        mats.sort(key=sort_key)
    else:
        mats = [m for m in materials if m.get("n_completed", 0) >= 1]

    if max_count:
        mats = mats[:max_count]
    return mats


def build_chemsys_families(materials):
    """Build chemical system family map from the database.

    Returns dict mapping material_id -> list of family member dicts.
    """
    chemsys_lookup = {}
    try:
        conn = get_conn()
        for row in conn.execute("SELECT material_id, chemsys FROM mp_cross_ref"):
            chemsys_lookup[row[0]] = row[1]
        conn.close()
    except Exception:
        return {}

    mat_by_id = {m["material_id"]: m for m in materials}
    chemsys_groups = {}
    for mid, cs in chemsys_lookup.items():
        chemsys_groups.setdefault(cs, []).append(mid)

    family_map = {}
    for mid, cs in chemsys_lookup.items():
        siblings = chemsys_groups.get(cs, [])
        if len(siblings) > 1:
            family_map[mid] = [mat_by_id[s] for s in siblings if s in mat_by_id]
    return family_map
